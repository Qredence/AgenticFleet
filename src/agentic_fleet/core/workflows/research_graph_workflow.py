import asyncio
import chainlit as cl

async def run_research_graph(task_description: str) -> dict:
    await cl.Message(content=f"Placeholder: Running research graph for: {task_description}", author="System").send()

    await cl.Message(content="Starting research and summarization phase...", author="System").send()

    # Illustrative TaskList for sub-tasks within research & summarization
    # In a real scenario, these tasks would be dynamically created and updated.
    # Attempt to attach to current step if available, otherwise it will be a root element.
    current_step_id = None
    if cl.context.current_step:
        current_step_id = cl.context.current_step.id

    sub_tasks = cl.TaskList(status="Running...", parent_id=current_step_id)

    # Hypothetical sub-tasks
    task1 = cl.Task(title="Defining research questions", status=cl.TaskStatus.RUNNING)
    task2 = cl.Task(title="Querying web sources", status=cl.TaskStatus.PENDING)
    task3 = cl.Task(title="Analyzing results", status=cl.TaskStatus.PENDING)
    task4 = cl.Task(title="Generating initial summary", status=cl.TaskStatus.PENDING)

    # It's important to add tasks to the list *before* sending the list for the first time
    # if you want them to be part of the initial display.
    # However, cl.TaskList.add_task also sends an update, so we can add then send.
    # For clarity, let's add all tasks, then send the list once.
    # Then, individual task updates will also trigger re-sends of the list.

    await sub_tasks.add_task(task1)
    await sub_tasks.add_task(task2)
    await sub_tasks.add_task(task3)
    await sub_tasks.add_task(task4)
    # The initial send of the task list itself. If tasks are added before, they are included.
    # If add_task is used, it implicitly sends updates.
    # To be explicit and ensure the list container is sent first if desired:
    await sub_tasks.send()

    # Simulate work and update tasks for illustration
    await asyncio.sleep(0.5)
    task1.status = cl.TaskStatus.DONE
    await task1.send() # Send update for the specific task, which should update the list

    await asyncio.sleep(0.5)
    task2.status = cl.TaskStatus.RUNNING
    await task2.send()
    await asyncio.sleep(0.5)
    task2.status = cl.TaskStatus.DONE
    await task2.send()

    await asyncio.sleep(0.5)
    task3.status = cl.TaskStatus.RUNNING
    await task3.send()
    await asyncio.sleep(0.5)
    task3.status = cl.TaskStatus.DONE
    await task3.send()

    await asyncio.sleep(0.5)
    task4.status = cl.TaskStatus.RUNNING
    await task4.send()
    await asyncio.sleep(0.5)
    task4.status = cl.TaskStatus.DONE
    await task4.send()

    sub_tasks.status = "Completed" # Update overall status of the TaskList
    await sub_tasks.send() # Send the final state of the TaskList

    await cl.Message(content="Research and summarization complete (including illustrative sub-tasks). Starting blog post generation...", author="System").send()
    await asyncio.sleep(1) # Simulate work for blog post generation

    await cl.Message(content="Blog post generation complete.", author="System").send()

    return {
        "task_description": task_description,
        "summary": f"This is a placeholder summary for the task: {task_description}",
        "blog_post": f"This is a placeholder blog post based on the summary for: {task_description}. Content will be generated by an agent."
    }
